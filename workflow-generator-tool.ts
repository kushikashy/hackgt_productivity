import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { generateObject } from 'ai';
import { openai } from '@ai-sdk/openai';

interface TeamRole {
  name: string;
  role: string;
  skills: string[];
}

interface Task {
  id: string;
  title: string;
  description: string;
  assignedTo: string;
  estimatedHours: number;
  dependencies?: string[];
  nextTask?: string;
  priority: 'high' | 'medium' | 'low';
}

export const workflowGeneratorTool = createTool({
  id: 'generate-workflow',
  description: 'Generate a structured workflow for hackathon teams based on time remaining, project description, and team roles',
  inputSchema: z.object({
    timeRemaining: z.number().describe('Time remaining in hours'),
    projectDescription: z.string().describe('Detailed description of the project'),
    teamRoles: z.array(
      z.object({
        name: z.string().describe('Team member name'),
        role: z.string().describe('Role (e.g., Frontend Developer, Backend Developer, Designer, etc.)'),
        skills: z.array(z.string()).describe('List of skills/expertise'),
      })
    ).describe('Array of team members with their roles and skills'),
  }),
  outputSchema: z.object({
    workflow: z.object({
      projectName: z.string(),
      totalDurationHours: z.number(),
      tasks: z.array(
        z.object({
          id: z.string().describe('Unique identifier for the task'),
          title: z.string().describe('Short title for the task'),
          description: z.string().describe('Brief description of the task'),
          assignedTo: z.string().describe('Name of the team member responsible'),
          estimatedHours: z.number().describe('Estimated hours to complete the task'),
          dependencies: z.array(z.string()).optional().describe('Array of task IDs this task depends on'),
          nextTask: z.string().optional().describe('ID of the next task that should follow after this one'),
          priority: z.enum(['high', 'medium', 'low']).describe('Priority level of the task'),
        })
      ),
    }),
  }),

  execute: async ({ context }: { context: { timeRemaining: number; projectDescription: string; teamRoles: TeamRole[] } }) => {
    const { timeRemaining, projectDescription, teamRoles } = context;
  
    const taskZ = z.object({
      id: z.string(),
      title: z.string(),
      description: z.string(),
      assignedTo: z.string(),
      estimatedHours: z.number(),
      dependencies: z.array(z.string()).optional(),
      nextTask: z.string().optional(),
      priority: z.enum(["high", "medium", "low"]),
    });
    const tasksObjectSchema = z.object({ tasks: z.array(taskZ) });
  
    const allTasks: Task[] = [];
  
    // Deterministic fallback generator (keeps tool usable if model fails)
    const fallback = (member: TeamRole, idx: number): Task[] => {
      const base = (timeRemaining / Math.max(1, teamRoles.length)) / 3;
      return [0,1,2].map(i => ({
        id: `${member.name.toLowerCase().replace(/\s+/g,"-")}-t${i+1}`,
        title: `${member.role} - task ${i+1}`,
        description: `Autogenerated task ${i+1} for ${member.name} (${member.role})`,
        assignedTo: member.name,
        estimatedHours: Math.max(0.5, Math.round(base * 10) / 10),
        dependencies: i === 0 ? [] : [`${member.name.toLowerCase().replace(/\s+/g,"-")}-t${i}`],
        nextTask: i < 2 ? `${member.name.toLowerCase().replace(/\s+/g,"-")}-t${i+2}` : undefined,
        priority: i === 0 ? "high" : "medium",
      })) as Task[];
    };
  
    for (let i = 0; i < teamRoles.length; ++i) {
      const member = teamRoles[i];
      const prompt = `
  You are a hackathon workflow planner. Do NOT give medical advice or diagnoses.
  Project: ${projectDescription}
  Team member: ${member.name}
  Role: ${member.role}
  Skills: ${JSON.stringify(member.skills)}
  Time remaining (hours): ${timeRemaining}
  
  Return ONLY a JSON object: { "tasks": [ ... ] } where each task has:
  id, title, description, assignedTo, estimatedHours, dependencies, nextTask, priority.
  `.trim();
  
      try {
        const result = await generateObject({
          model: openai("gpt-4o"),
          schema: tasksObjectSchema,
          prompt,
        });
  
        // Validate & unwrap into Task[]
        const parsed = tasksObjectSchema.parse(result as unknown);
        // ensure assignedTo fallback
        parsed.tasks.forEach(t => {
          if (!t.assignedTo) t.assignedTo = member.name;
          allTasks.push(t as Task);
        });
      } catch (err) {
        console.error(`generateObject failed for ${member.name}:`, err);
        // fallback deterministic tasks so we always return something
        allTasks.push(...fallback(member, i));
      }
    }
  
    // normalize unique ids
    const seen = new Set<string>();
    for (let idx=0; idx<allTasks.length; ++idx) {
      if (!allTasks[idx].id) allTasks[idx].id = `task-${idx+1}`;
      if (seen.has(allTasks[idx].id)) {
        allTasks[idx].id = `${allTasks[idx].id}-${idx}`;
      }
      seen.add(allTasks[idx].id);
    }
  
    return {
      workflow: {
        projectName: "Generated Project Workflow",
        totalDurationHours: timeRemaining,
        tasks: allTasks,
      },
    };
  },
  
});